#![no_std]
#![no_main]

use core::sync::atomic::AtomicU32;

use defmt::*;
use embassy_executor::Spawner;
use embassy_stm32::exti::{AnyChannel, Channel, ExtiInput};
use embassy_stm32::gpio::{AnyPin, Input, Level, Output, Pin, Pull, Speed};
use embassy_sync::blocking_mutex::raw::{CriticalSectionRawMutex, ThreadModeRawMutex};
use embassy_sync::mutex::Mutex;
use embassy_sync::signal::Signal;
use embassy_time::{with_timeout, Duration, Ticker};
use {defmt_rtt as _, panic_probe as _};

/// Global state
/// The countdown itself
static COUNTDOWN: AtomicU32 = AtomicU32::new(0);
/// The signal generated by a button press
static BUTTON_SIGNAL: Signal<CriticalSectionRawMutex, ButtonEvent> = Signal::new();
/// The state of the timer, which is only updated by the button press handler
static TIMER_STATE: Mutex<ThreadModeRawMutex, TimerState> = Mutex::new(TimerState::Reset);

#[derive(Debug, Format)]
enum TimerState {
    Running,
    Paused,
    Reset,
}

const POMO_DURATION_SECS: Duration = Duration::from_secs(25 * 60);
//const POMO_DURATION_SECS: Duration = Duration::from_secs(1 * 60);

#[embassy_executor::task]
async fn pomo_timer_task() {
    let mut ticker = Ticker::every(Duration::from_millis(1000));
    loop {
        ticker.next().await;
        let guard = TIMER_STATE.lock().await;
        match *guard {
            TimerState::Running => {
                if COUNTDOWN.load(core::sync::atomic::Ordering::Relaxed) > 0 {
                    COUNTDOWN.fetch_sub(1, core::sync::atomic::Ordering::Relaxed);
                }
            }
            TimerState::Paused => {}
            TimerState::Reset => {
                let duration = POMO_DURATION_SECS.as_secs();
                COUNTDOWN.store(duration as u32, core::sync::atomic::Ordering::Relaxed);
            }
        }
    }
}

enum ButtonEvent {
    ShortPress,
    LongPress,
}

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    info!("Hello Pomodoro-AF!");
    let p = embassy_stm32::init(Default::default());

    // TODO -- Get previous state of the system from non-volitile memory

    // Spawn background tasks
    spawner
        .spawn(button_task(p.PC13.degrade(), p.EXTI13.degrade()))
        .unwrap();
    spawner.spawn(pomo_timer_task()).unwrap();
    spawner.spawn(heartbeat_task(p.PA5.degrade())).unwrap();

    // Main event loop
    loop {
        match BUTTON_SIGNAL.wait().await {
            ButtonEvent::ShortPress => {
                info!("Short Press Event");
                let mut guard = TIMER_STATE.lock().await;
                match *guard {
                    TimerState::Running => {
                        *guard = TimerState::Paused;
                    }
                    TimerState::Paused => {
                        *guard = TimerState::Running;
                    }
                    TimerState::Reset => {
                        *guard = TimerState::Running;
                    }
                }
            }
            ButtonEvent::LongPress => {
                info!("Long Press Event");
                let mut guard = TIMER_STATE.lock().await;
                match *guard {
                    TimerState::Running => {
                        *guard = TimerState::Reset;
                    }
                    TimerState::Paused => {
                        *guard = TimerState::Reset;
                    }
                    TimerState::Reset => {}
                }
            }
        };
    }
}

// Heartbeat task that toggles an LED every 1/2 second
#[embassy_executor::task]
async fn heartbeat_task(pin: AnyPin) {
    let mut led = Output::new(pin, Level::High, Speed::Low);
    // Use a ticker instead of a timer because it guarantees that
    // it will fire every interval instead of every interval plus the time it takes
    // to toggle the led.
    // https://github.com/embassy-rs/embassy/blob/main/embassy-time/src/timer.rs#L157
    let mut ticker = Ticker::every(Duration::from_millis(500));
    loop {
        led.toggle();
        info!(
            "countdown: {}",
            COUNTDOWN.load(core::sync::atomic::Ordering::Relaxed)
        );
        ticker.next().await;
    }
}

// Task that just looks for long or short button presses
//
// Long press is hard-coded as >= 2 seconds
// Only one event signal will be sent after the long press no matter how long
// the button is held down.
#[embassy_executor::task]
async fn button_task(pin: AnyPin, exti_chan: AnyChannel) {
    let mut button = ExtiInput::new(Input::new(pin, Pull::Down), exti_chan);
    // Do we need to debounce or is that done by Embassy?
    loop {
        button.wait_for_falling_edge().await;
        info!("FALLING EDGE");
        match with_timeout(Duration::from_millis(2000), button.wait_for_rising_edge()).await {
            Ok(_) => {
                BUTTON_SIGNAL.signal(ButtonEvent::ShortPress);
            }
            Err(_) => {
                BUTTON_SIGNAL.signal(ButtonEvent::LongPress);
            }
        };
    }
}
